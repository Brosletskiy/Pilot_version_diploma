export type DrawingParams = {
    inputType: 'bmp' | null;
    bmpFile?: File | null;
    rows: number;
    cols: number;
    selectedBlocks?: string[];
    selectedDirection?: 'top-bottom' | 'bottom-top' | 'left-right' | 'right-left';
    fps?: number;
    heightVideo?: number;
    widthVideo?: number;
    colorVideoBack?: string;
    onProgress?: (percent: number) => void;
};

export async function generateVideoWithHandAnimation({
    inputType,
    bmpFile,
    handImages,
    rows,
    cols,
    selectedBlocks = [],
    selectedDirection = 'top-bottom',
    colorVideoBack = "#fff",
    heightVideo = 720,
    widthVideo = 1280,
    fps = 24,
    onProgress
}: DrawingParams & { handImages: HTMLImageElement[] }): Promise<{ videoUrl: string }> {

    if (!inputType) throw new Error("❌ Не вказано тип введення.");
    if (!bmpFile) throw new Error("❌ BMP файл не вказано.");
    if (!handImages || handImages.length === 0) throw new Error("❌ Зображення руки не надано.");

    const canvas = document.createElement("canvas");
    canvas.width = widthVideo;
    canvas.height = heightVideo;
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("❌ Не вдалося отримати 2D контекст.");

    ctx.fillStyle = colorVideoBack;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Завантаження BMP
    const imgBMP = new Image();
    await new Promise<void>((res, rej) => {
        imgBMP.onload = () => res();
        imgBMP.onerror = () => rej(new Error("❌ Не вдалося завантажити BMP"));
        imgBMP.src = URL.createObjectURL(bmpFile);
    });

    // Допоміжний canvas для BMP
    const offCanvas = document.createElement("canvas");
    offCanvas.width = imgBMP.width;
    offCanvas.height = imgBMP.height;
    const offCtx = offCanvas.getContext("2d")!;
    offCtx.drawImage(imgBMP, 0, 0);

    const bmpImageData = offCtx.getImageData(0, 0, imgBMP.width, imgBMP.height);

    // Розмір блоків
    const blockWidth = Math.floor(imgBMP.width / cols);
    const blockHeight = Math.floor(imgBMP.height / rows);

    // Матриця пікселів — стан 0|1|2|3
    const matrix: number[][] = [];
    for (let y = 0; y < imgBMP.height; y++) {
        matrix[y] = [];
        for (let x = 0; x < imgBMP.width; x++) {
            const i = (y * imgBMP.width + x) * 4;
            const r = bmpImageData.data[i];
            const g = bmpImageData.data[i + 1];
            const b = bmpImageData.data[i + 2];
            const brightness = 0.34 * r + 0.5 * g + 0.16 * b;
            matrix[y][x] = brightness < 230 ? 1 : 0; // 1 — потенційний піксель для малювання
        }
    }

    // Фільтрація пікселів відповідно до вибраних блоків
    let blocksToDraw: string[];
    const allBlocks = Array.from({ length: rows * cols }, (_, idx) => `${Math.floor(idx / cols)}-${idx % cols}`);

    if (selectedBlocks.length > 0) {
        blocksToDraw = selectedBlocks.filter(b => allBlocks.includes(b));
    } else {
        blocksToDraw = allBlocks;
    }
    const blockSet = new Set(blocksToDraw);

    // Позначити пікселі, які не в обраних блоках, як фон (0)
    for (let blockId of allBlocks) {
        if (!blockSet.has(blockId)) {
            const [br, bc] = blockId.split('-').map(Number);
            const startY = br * blockHeight;
            const startX = bc * blockWidth;
            for (let y = startY; y < Math.min(startY + blockHeight, imgBMP.height); y++) {
                for (let x = startX; x < Math.min(startX + blockWidth, imgBMP.width); x++) {
                    matrix[y][x] = 0;
                }
            }
        }
    }

    // Функція для отримання координат пікселя '1' в обраному напрямку
    // Перший піксель для старту — найближчий до лівого верхнього кута серед 1 в блоках
    function findStartPixel(): { x: number, y: number } | null {
        for (let br = 0; br < rows; br++) {
            for (let bc = 0; bc < cols; bc++) {
                let bid = `${br}-${bc}`;
                if (!blockSet.has(bid)) continue;
                const startY = br * blockHeight;
                const startX = bc * blockWidth;
                // Сканування залежно від напрямку
                // Для спрощення — сканаємо зверху вниз, зліва направо
                for (let y = startY; y < Math.min(startY + blockHeight, imgBMP.height); y++) {
                    for (let x = startX; x < Math.min(startX + blockWidth, imgBMP.width); x++) {
                        if (matrix[y][x] === 1) return { x, y };
                    }
                }
            }
        }
        return null;
    }

    // Починаємо з початкової точки
    const startPixel = findStartPixel();
    if (!startPixel) throw new Error("Немає пікселів для малювання в обраних блоках");
    matrix[startPixel.y][startPixel.x] = 3; // позначаємо піксель як "малюємо"

    // Функція для отримання центру фломастера (середнє для всіх пікселів зі станом 3)
    function getMarkerCenter() {
        let sumX = 0, sumY = 0, count = 0;
        for (let y = 0; y < matrix.length; y++) {
            for (let x = 0; x < matrix[y].length; x++) {
                if (matrix[y][x] === 3) {
                    sumX += x;
                    sumY += y;
                    count++;
                }
            }
        }
        if (count === 0) return null;
        return { x: sumX / count, y: sumY / count };
    }

    // Функція малювання кадру
    function drawFrame() {
        if(!ctx){
            throw("error 2d download");
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = colorVideoBack;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let scale = Math.min(canvas.width / imgBMP.width, canvas.height / imgBMP.height);
        let offsetX = (canvas.width - imgBMP.width * scale) / 2;
        let offsetY = (canvas.height - imgBMP.height * scale) / 2;

        // Створюємо ImageData тільки з намальованими пікселями
        const imageData = ctx.createImageData(imgBMP.width, imgBMP.height);
        for (let y = 0; y < imgBMP.height; y++) {
            for (let x = 0; x < imgBMP.width; x++) {
                const i = (y * imgBMP.width + x) * 4;
                if (matrix[y][x] === 2) {
                    imageData.data[i] = bmpImageData.data[i];
                    imageData.data[i + 1] = bmpImageData.data[i + 1];
                    imageData.data[i + 2] = bmpImageData.data[i + 2];
                    imageData.data[i + 3] = 255;
                } else {
                    imageData.data[i + 3] = 0;
                }
            }
        }
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = imgBMP.width;
        tempCanvas.height = imgBMP.height;
        tempCanvas.getContext("2d")!.putImageData(imageData, 0, 0);
        ctx.drawImage(tempCanvas, offsetX, offsetY, imgBMP.width * scale, imgBMP.height * scale);

        // Рух фломастера — малюємо руку на позиції центру
        const marker = getMarkerCenter();
        if (marker) {
            const handImg = handImages[0]; // для прикладу беремо перше
            const handW = 100; // підлаштуйте під зображення руки
            const handH = 100;
            const handX = offsetX + marker.x * scale - 80; // зміщення для кінчика фломастера
            const handY = offsetY + marker.y * scale - 90;
            ctx.drawImage(handImg, handX, handY, handW, handH);
        }
    }

    // Функція оновлення матриці за правилами (1..4), які описали ви
    function updateMatrix(): boolean {
        let updated = false;
        const newMatrix = matrix.map(row => [...row]);

        for (let y = 0; y < matrix.length; y++) {
            for (let x = 0; x < matrix[y].length; x++) {
                if (matrix[y][x] === 3) {
                    newMatrix[y][x] = 2;

                    // Правила замальовування

                    // (1) вправо
                    if (x + 1 < matrix[0].length && matrix[y][x + 1] === 1) newMatrix[y][x + 1] = 3;
                    // (2) вліво
                    if (x - 1 >= 0 && matrix[y][x - 1] === 1) newMatrix[y][x - 1] = 3;
                    // (3) вгору
                    if (y - 1 >= 0 && matrix[y - 1][x] === 1) newMatrix[y - 1][x] = 3;
                    // (4) вниз
                    if (y + 1 < matrix.length && matrix[y + 1][x] === 1) newMatrix[y + 1][x] = 3;

                    updated = true;
                }
            }
        }

        matrix.splice(0, matrix.length, ...newMatrix);
        return updated;
    }

    // Медiарекордер для запису відео
    const mediaRecorder = new MediaRecorder(canvas.captureStream(fps), { mimeType: 'video/webm; codecs=vp8' });
    const recordedChunks: Blob[] = [];
    mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };

    // Анімація з оновленням матриці та малюванням
    return new Promise<{ videoUrl: string }>(resolve => {
        mediaRecorder.start();

        function frame() {
            drawFrame();
            const cont = updateMatrix();

            // Прогрес віддаємо за бажанням
            if (onProgress) {
                const total = matrix.flat().filter(c => c === 1 || c === 2 || c === 3).length;
                const drawn = matrix.flat().filter(c => c === 2).length;
                onProgress((drawn / total) * 100);
            }

            if (cont) {
                requestAnimationFrame(frame);
            } else {
                // Шукаємо нову точку старту, якщо пікселі лишились
                let started = false;
                for (let y = 0; y < matrix.length && !started; y++) {
                    for (let x = 0; x < matrix[y].length && !started; x++) {
                        if (matrix[y][x] === 1) {
                            matrix[y][x] = 3;
                            started = true;
                        }
                    }
                }
                if (started) {
                    requestAnimationFrame(frame);
                } else {
                    mediaRecorder.stop();
                }
            }
        }

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            resolve({ videoUrl: URL.createObjectURL(blob) });
        };

        frame();
    });
}
